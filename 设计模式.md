# 一、单例模式

**概念：**确保一个类只有一个实例，并提供一个全局访问点来获取

```
┌─────────────────────────┐
│      Singleton          │
├─────────────────────────┤
│ - instance: Singleton   │
│ - Singleton()           │
├─────────────────────────┤
│ + getInstance(): Singleton │
│ + someBusinessMethod()  │
└─────────────────────────┘
```

## 饿汉式单例

类加载时就创建实例，线程安全，但是可能会造成资源浪费

```
public class EagerSingleton {
    
    // 在类加载时就创建实例
    private static final EagerSingleton INSTANCE = new EagerSingleton();
    
    // 私有构造函数，防止外部实例化
    private EagerSingleton() {
        System.out.println("EagerSingleton 实例被创建");
    }
    
    // 提供全局访问点
    public static EagerSingleton getInstance() {
        return INSTANCE;
    }
    
    // 业务方法
    public void doSomething() {
        System.out.println("执行业务逻辑");
    }
}
可以通过禁止反射创建实例来增强方法
// 防止反射攻击
        if (INSTANCE != null) {
            throw new RuntimeException("不允许通过反射创建单例实例");
        }
```

### ik分词器

```
public class Configuration {
    /*
     * 分词器配置文件路径
     */    
    private static final String FILE_NAME = "/IKAnalyzer.cfg.xml";
    //配置属性——扩展字典
    private static final String EXT_DICT = "ext_dict";
    //配置属性——扩展停止词典
    private static final String EXT_STOP = "ext_stopwords";
    
    private static final Configuration CFG = new Configuration();
    
    private Properties props;
    
    /*
     * 初始化配置文件
     */
    private Configuration(){
       
       props = new Properties();
       
       InputStream input = Configuration.class.getResourceAsStream(FILE_NAME);
       if(input != null){
          try {
             props.loadFromXML(input);
          } catch (InvalidPropertiesFormatException e) {
             e.printStackTrace();
          } catch (IOException e) {
             e.printStackTrace();
          }
       }
    }
}
在Ik分词器的Configuration类中就用到了单例模式，确保只会创建一个配置类
```

## 懒汉式单例

### 线程不安全版本

```
/**
 * 懒汉式单例 - 线程不安全版本
 * 
 * 问题：多线程环境下可能创建多个实例
 */
public class UnsafeLazySingleton {
    
    private static UnsafeLazySingleton instance;
    
    private UnsafeLazySingleton() {}
    
    public static UnsafeLazySingleton getInstance() {
        if (instance == null) {  // 线程不安全的检查
            instance = new UnsafeLazySingleton();
        }
        return instance;
    }
}
```

### 线程安全版本

```
/**
 * 懒汉式单例 - 同步方法版本（使用了sychronized关键字）
 * 
 * 优点：线程安全
 * 缺点：性能较差，每次获取实例都需要同步
 */
public class SynchronizedLazySingleton {
    
    private static SynchronizedLazySingleton instance;
    
    private SynchronizedLazySingleton() {}
    
    public static synchronized SynchronizedLazySingleton getInstance() {
        if (instance == null) {
            instance = new SynchronizedLazySingleton();
        }
        return instance;
    }
}
```

### 双重检查锁定版本

```
/**
 * 懒汉式单例 - 双重检查锁定版本（推荐）
 * 
 * 优点：线程安全，性能较好
 * 关键点：volatile关键字防止指令重排序
 */
public class DoubleCheckLockingSingleton {
    
    // volatile确保多线程环境下的可见性和防止指令重排序
    private static volatile DoubleCheckLockingSingleton instance;
    
    private DoubleCheckLockingSingleton() {
        // 防止反射攻击
        if (instance != null) {
            throw new RuntimeException("不允许创建多个实例");
        }
    }
    
    public static DoubleCheckLockingSingleton getInstance() {
        if (instance == null) {  // 第一次检查
            synchronized (DoubleCheckLockingSingleton.class) {
                if (instance == null) {  // 第二次检查
                    instance = new DoubleCheckLockingSingleton();
                }
            }
        }
        return instance;
    }
}
```

### volatile关键词

```
/**
 * volatile在双重检查锁定中的重要性
 */
public class VolatileAnalysis {
    
    // 没有volatile的问题版本
    private static BadSingleton badInstance;
    
    // 有volatile的正确版本
    private static volatile GoodSingleton goodInstance;
    
    /**
     * 问题分析：没有volatile可能导致的问题
     * 
     * 1. 可见性问题：线程A创建实例后，线程B可能看不到
     * 2. 指令重排序问题：
     *    - 正常顺序：分配内存 -> 初始化对象 -> 赋值给变量
     *    - 重排序后：分配内存 -> 赋值给变量 -> 初始化对象
     *    - 结果：其他线程可能看到未完全初始化的对象
     */
    
    public static BadSingleton getBadInstance() {
        if (badInstance == null) {  // 检查1
            synchronized (VolatileAnalysis.class) {
                if (badInstance == null) {  // 检查2
                    // 这里可能发生指令重排序
                    badInstance = new BadSingleton();
                }
            }
        }
        return badInstance;  // 可能返回未完全初始化的对象
    }
    
    public static GoodSingleton getGoodInstance() {
        if (goodInstance == null) {  // 检查1
            synchronized (VolatileAnalysis.class) {
                if (goodInstance == null) {  // 检查2
                    // volatile防止指令重排序
                    goodInstance = new GoodSingleton();
                }
            }
        }
        return goodInstance;  // 保证返回完全初始化的对象
    }
```

### 静态内部类实现

```
/**
 * 静态内部类单例（推荐实现）
 * 
 * 优点：
 * 1. 线程安全（JVM保证类加载的线程安全）
 * 2. 延迟加载（只有调用getInstance时才加载内部类）
 * 3. 性能优秀（无锁）
 * 4. 实现简洁
 */
public class StaticInnerClassSingleton {
    
    // 私有构造函数
    private StaticInnerClassSingleton() {
        // 防止反射攻击
        if (SingletonHolder.INSTANCE != null) {
            throw new RuntimeException("不允许创建多个实例");
        }
    }
    
    // 静态内部类
    private static class SingletonHolder {
        // 静态常量，类加载时初始化
        private static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();
    }
    
    // 公共访问方法
    public static StaticInnerClassSingleton getInstance() {
        return SingletonHolder.INSTANCE;  // 触发内部类加载
    }
    
    public void doSomething() {
        System.out.println("静态内部类单例执行业务逻辑");
    }
}
```

### 防反射

```
private ReflectionProofSingleton() {
        synchronized (ReflectionProofSingleton.class) {
            if (initialized) {
                throw new RuntimeException("不允许通过反射创建实例");
            }
            initialized = true;
        }
    }
```

### 防克隆

```
@Override
    protected Object clone() throws CloneNotSupportedException {
        throw new CloneNotSupportedException("不允许克隆单例对象");
    }
```

### 防序列化

```
   private Object readResolve() {
        return getInstance();
    }
     /*
     * JVM反序列化步骤：
     * 
     * 1. 读取序列化数据
     * 2. 创建对象实例（调用构造函数或使用反射）
     * 3. 恢复对象状态（设置字段值）
     * 4. 检查是否有 readResolve() 方法
     * 5. 如果有 readResolve()，调用该方法并返回其结果
     * 6. 如果没有 readResolve()，返回步骤2创建的实例
     */
```